// 유현이가 새 집으로 이사했다.
// 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1 ×1 크기의 정사각형 칸으로 나누어져 있다.
// 각각의 칸은 (r, c)로 나타낼 수 있다.
// 여기서 r은 행의 번호, c는 열의 번호이고, 행과 열의 번호는 1부터 시작한다.
// 각각의 칸은 빈 칸이거나 벽이다.
// 오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다.
// 파이프는 아래와 같은 형태이고, 2개의 연속된 칸을 차지하는 크기이다.
// 파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능하다.
// 파이프는 매우 무겁기 때문에, 유현이는 파이프를 밀어서 이동시키려고 한다.
// 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다.
// 즉, 파이프는 항상 빈칸만 차지해야 한다.
// 파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다.
// 파이프는 밀면서 회전시킬 수 있다.
// 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.
// 파이프가 가로로 놓여진 경우에 가능한 이동 방법은 총 2가지, 세로로 놓인 경우에는 2가지, 대각선 방향으로 놓인 경우에는 3가지가 있다.
// 아래 그림은 파이프가 놓여진 방향에 따라서 이동할 수 있는 방법을 모두 나타낸 것이고, 꼭 빈칸이어야 하는 곳은 색으로 표시되어 있다.
// 먼저 이 문제는 가능하긴 하지만 BFS를 권장하지 않는다고 말하고 싶다.
// BFS는 최단 경로를 찾을 때 유용한 알고리즘인데, 이 문제는 방문 여부와 상관없이 전부 여러 번 방문해야 하기 때문에 맞지 않다.
// queue를 사용한 브루트 포스 알고리즘이라고 보면 될 것 같다.
// 너비 우선적으로 완전탐색하기 때문이다.

// DFS를 활용하면 쉽게 풀 수 있는 문제
// 처음에, visited 배열을 사용하지 않는 BFS 방식으로 문제를 풀려고 했으나, 계속 0%에서 시간초과가 발생
// 이러한 로직은 java에서는 안 되지만 C++에서는 된다는 것을 확인
// 대부분 BFS로 시간 초과가 나신 분들은 중복된 케이스를 배제한 브루트포스로 풀이하였기때문에 발생
// 어떻게 고쳐야될지 감이 잘 안잡혀서 결국 재귀함수를 활용한 DFS로 노선을 변경
// BFS는 같은 정점을 한 번 방문해야 하는데, 같은 정점을 여러 번 방문하는 BFS와 같은 소스가 많습니다.
// 이건 브루트 포스를 Queue를 이용해서 BFS처럼 구현한 것
// 로직 자체는 상당히 단순 , 거의 구현 문제 급
// 7가지 경우의 수에 맞춰서 visited 배열도 필요 없이 주어진 조건 하에, x = N, y = N에 도달할 때까지 탐색
// 로직은 다음과 같습니다.
// 1. 파이프의 끝점을 기준
// 2. 파이프가 가로 방향일 경우, 동쪽으로 한 칸 또는 대각선으로 한 칸 이동
// 3. 파이프가 세로 방향일 경우, 남쪽으로 한 칸 또는 대각선으로 한 칸 이동
// 4. 파이프가 대각선 방향일 경우, 동쪽으로 한 칸 또는 남쪽으로 한 칸 또는 대각선으로 한 칸 이동

// 파이프가 이동할 때, 벽이 없어야 하고 범위를 초과하면 안 된다는 점을 유의

import java.io.*;
import java.util.*;

public class PipePlace_bj {
    // static: 한 클래스에서 공통적인 값을 유지 && 클래스가 메모리에 로딩될때 생성
    static int N;
    static int[][] map;
    static int ans;

    public static void main(String[] args) throws Exception {
        // Scanner와 달리 BufferedReader는 개행문자만 경계로 인식
        // 입력받은 데이터가 String으로 고정
        // Scanner보다 속도가 빠르다
        // 동기화 되기 때문에 멀티 쓰레드 환경에서 안전
        // InputStream 를 문자단위(character) 데이터로 변환시키는 중간다리 역할
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // 입력은 readLine();이라는 메소드를 사용
        // String으로 리턴 값이 고정되어 있기 때문에, 다른 타입으로 입력을 받고자 한다면 반드시 형변환이 필요
        // 그리고, 예외처리를 반드시 필요
        // readLine()시 마다 try/catch문으로 감싸주어도 되고, throws IOException 을 통한 예외처리를 해도 된다
        int N = Integer.parseInt(br.readLine());

        // 일반적으로 출력을 할 때, System.out.println(""); 을 사용
        // 적은 양의 출력에서는 편리하고, 그렇게 큰 성능 차이 없이 사용할 수 있다.
        // 하지만 우리가 늘 고려해야하는 경우는 양이 많을 경우
        // 많은 양의 출력을 할 때는, 입력과 동일하게 버퍼를 사용
        // BufferedWriter는 System.out.println(""); 처럼 출력과 개행을 동시해 해주지 않는다
        // 개행을 위해선 따로 newLine(); 혹은 bw.write("\n");을 사용
        // 그리고 BufferedWriter의 경우 버퍼를 잡아 놓았기 때문에 반드시 사용한 후에, flush()/ close()를 해주어야 한다.
        // close()를 하게되면, 출력 스트림을 아예 닫아버리기 때문에 한번 출력후, 다른 것도 출력하고자 한다면 flush()를 사용하면 된다.
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        // StringTokenizer 클래스는 문자열을 구분자를 이용하여 분리할 때 사용
        // 만일 BufferedReader 클래스의 메서드로 입력을 읽어들인다면 라인 단위로 읽어들일 수 밖에 없습니다
        // 꼭 BufferedReader 클래스만이 아니더라도, 스페이스 기준으로 혹은 컴마로 혹은 공백을 기준으로 문자열들을 분리한다던가,
        // 특정 문자에 따라 문자열을 나누고 싶을 때 StringTokenizer를 사용
        // 즉, 토큰은 분리된 문자열 조각으로, StringTokenizer 클래스는 하나의 문자열을 여러 개의 토큰으로 분리하는 클래스
        StringTokenizer st;

        int[][] map = new int[N + 1][N + 1];
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        int ans = 0;
        DFS(1, 2, 0);

        bw.write(ans + "\n");
        bw.flush();
        bw.close();
        br.close();
    }

    // x는 세로, y는 가로
    // direction이 0일 때는 파이프가 가로 방향, 1일 때는 세로 방향, 2일 때는 대각선 방향.
    public static void DFS(int x, int y, int direction) {
        // 종료 조건
        if (x == N && y == N) {
            ans++;
            return;
        }
        switch (direction) {
            // 파이프가 가로 방향일 경우, 갈 수 있는 경우는 동쪽과 대각선임.
            case 0:
                // 동쪽
                if (y + 1 <= N && map[x][y + 1] == 0) {
                    DFS(x, y + 1, 0);
                }
                break;
            // 파이프가 세로 방향일 경우, 갈 수 있는 경우는 남쪽과 대각선임.
            case 1:
                // 남쪽
                if (x + 1 <= N && map[x + 1][y] == 0) {
                    DFS(x + 1, y, 1);
                }
                break;
            // 파이프가 대각선일 경우, 갈 수 있는 경우는 동쪽과 남쪽, 대각선임.
            case 2:
                // 동쪽
                if (y + 1 <= N && map[x][y + 1] == 0) {
                    DFS(x, y + 1, 0);
                }
                // 남쪽
                if (x + 1 <= N && map[x + 1][y] == 0) {
                    DFS(x + 1, y, 1);
                }
                break;
        }

        // 파이프가 어떤 방향이든지, 대각선은 검사해서 가장 아래로 뺐음.
        if (y + 1 <= N && x + 1 <= N && map[x][y + 1] == 0 && map[x + 1][y] == 0 && map[x + 1][y + 1] == 0) {
            DFS(x + 1, y + 1, 2);
        }
    }
}